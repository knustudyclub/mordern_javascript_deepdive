## 4.4 변수 선언의 실행 시점과 변수 호이스팅

자바스크립트에서 **변수 선언**은 실행 전에 선언 단계에서 끌어올려집니다.  
이를 **변수 호이스팅(Variable Hoisting)**이라고 합니다. 즉, 변수 선언문이 코드 상의 위치와 관계없이  
자바스크립트 엔진에 의해 코드의 맨 위로 끌어올려져 먼저 처리됩니다.

그러나 중요한 점은, 선언만 호이스팅되고 값의 할당은 호이스팅되지 않기 때문에,  
변수 선언 후 초기 값은 `undefined`가 됩니다. 값의 할당은 런타임에 이루어집니다.

### 예시:
```javascript
console.log(score);  // undefined
var score = 80;
console.log(score);  // 80
```

### 설명:
1. `console.log(score)`는 `score`가 선언되었지만 아직 값이 할당되지 않았기 때문에 `undefined`를 출력합니다.
2. `var score = 80;` 이후로 값이 `80`으로 할당됩니다.
3. 두 번째 `console.log(score)`는 이제 `80`을 출력합니다.

변수 선언은 호이스팅되지만 값의 할당은 나중에 실행되므로, 처음에는 `undefined`가 출력됩니다.

---

## 4.5 값의 할당

자바스크립트에서 **변수 선언**과 **값의 할당**은 별개의 과정입니다.  
변수에 값을 할당할 때는 **할당 연산자(=)**를 사용합니다.

변수 선언은 코드 실행 전에 먼저 처리되지만, 값의 할당은 런타임 시에 이루어집니다.  
따라서, 변수는 선언만 되었을 때는 기본 값인 `undefined`로 설정되며, 이후 값이 할당되면 그 값으로 업데이트됩니다.

### 예시:
```javascript
var score;  // 변수 선언, 값은 undefined
score = 100;  // 값 할당
console.log(score);  // 100
```

### 설명:
1. `var score;`는 변수를 선언하지만, 아직 값이 할당되지 않았으므로 초기 값은 `undefined`입니다.
2. `score = 100;`을 통해 `score`에 값 `100`을 할당합니다.
3. `console.log(score);`를 호출하면 이제 `100`이 출력됩니다.

---

## 4.6 변수 선언의 종류와 네이밍 규칙

자바스크립트에서는 변수 이름을 작성할 때 다양한 네이밍 규칙을 따릅니다.  
이러한 네이밍 규칙은 코드의 가독성과 일관성을 유지하는 데 중요한 역할을 합니다.

- **카멜 케이스(camelCase)**: 변수나 함수 이름에 주로 사용. 예: `firstName`, `myVariable`
- **스네이크 케이스(snake_case)**: 일반적으로 상수나 파일 이름에 사용. 예: `first_name`, `my_variable`
- **파스칼 케이스(PascalCase)**: 클래스 이름에 사용. 예: `FirstName`, `MyClass`
- **헝가리언 케이스(typeHungarianCase)**: 변수의 타입을 이름에 포함. 예: `strFirstName`, `intAge`

### 예시:
```javascript
// 카멜 케이스
var userName = 'John';

// 스네이크 케이스
const MAX_COUNT = 100;

// 파스칼 케이스
class Person {
  constructor(name) {
    this.name = name;
  }
}

// 헝가리언 케이스
var strGreeting = 'Hello';
```

---

## 가비지 컬렉터 (Garbage Collector)

**가비지 컬렉터(Garbage Collector)**는 자바스크립트에서 더 이상 사용되지 않는 메모리를 자동으로 해제하는 기능입니다.  
자바스크립트는 참조되지 않는 변수나 값이 더 이상 필요하지 않다고 판단되면, 이를 메모리에서 자동으로 제거합니다.  
이 과정은 주기적으로 실행되며, 이를 통해 **메모리 누수**를 방지합니다.

가비지 컬렉터는 자바스크립트 엔진이 관리하며, 개발자가 직접 메모리를 해제하지 않아도 됩니다.

### 예시:
```javascript
var obj = { name: 'John' };
obj = null;  // 이전에 참조된 객체는 이제 참조되지 않음, 가비지 컬렉터가 이를 메모리에서 제거

function createObject() {
  var localObj = { greeting: 'Hello' };
  // 함수가 끝나면 localObj는 더 이상 참조되지 않음
  // 가비지 컬렉터가 이를 감지하고 메모리에서 제거
}
```

### 설명:
1. `obj = null;`을 통해 `obj` 변수가 더 이상 객체를 참조하지 않게 되면, 가비지 컬렉터가 그 객체를 메모리에서 제거합니다.
2. `createObject` 함수 내에서 선언된 `localObj`는 함수 종료 후 더 이상 참조되지 않으므로 가비지 컬렉터가 이를 처리합니다.

자바스크립트의 가비지 컬렉터는 개발자가 직접 메모리를 관리할 필요 없이 자동으로 처리되기 때문에 편리하지만, 때로는 성능 저하의 원인이 될 수 있어 주의가 필요합니다.



## 5.6 표현식인 문과 표현식이 아닌 문

- **표현식**은 문에서 값으로 평가될 수 있는 문을 의미합니다. 반면, **표현식이 아닌 문**은 값으로 평가되지 않으며, 변수에 할당될 수 없습니다.
- **변수 선언문**은 표현식이 아닌 문에 해당하며, 값이 없으므로 평가할 수 없습니다.
- **할당문**은 표현식으로, 값으로 평가될 수 있기 때문에 변수에 할당될 수 있습니다.

### 표현식인 문과 표현식이 아닌 문 구별 방법
- 가장 간단한 방법은 변수가 할당될 수 있는지 확인하는 것입니다. **표현식이 아닌 문**은 값으로 평가되지 않기 때문에 할당 시 에러가 발생합니다.

### 예시:
```javascript
// 표현식이 아닌 문 (변수 선언문)
var x; // 값으로 평가되지 않음, 할당할 수 없음

// 표현식인 문 (할당문)
var y = 10; // 값으로 평가됨, 변수에 할당 가능

// 표현식이 아닌 문 (조건문)
if (y > 5) {
    console.log('y는 5보다 큽니다');
}

// 표현식인 문 (연산자 사용)
var z = y + 5; // y + 5는 값으로 평가되므로 표현식인 문
```
---

### 완료 값 (Completion Value)
- 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 `undefined`가 출력된다. 
- 완료 값은 평가된 값이 아닌 문을 실행한 결과로 얻는 값이다. 
- 표현식이 아닌 문을 실행하면 언제나 `undefined`가 반환되며, 이는 값으로 평가되지 않는다. 따라서 다른 값과 결합하거나 변수에 할당할 수 없다.

---

- 표현식인 문은 평가된 값을 반환하지만, 표현식이 아닌 문은 평가된 값을 반환하지 않는다. 
- 크롬 개발자 도구에서는 표현식이 아닌 문을 실행한 경우, 완료 값으로 `undefined`를 반환하며, 이는 변수가 값으로 평가되지 않기 때문이다.

## 완료 값 (Completion Value)

- 크롬 개발자 도구에서 **표현식이 아닌 문**을 실행하면 **`undefined`**가 출력됩니다.
- 완료 값은 **평가된 값이 아닌 문**을 실행한 결과로 얻는 값입니다.
- 표현식이 아닌 문을 실행하면 언제나 `undefined`가 반환되며, 이는 값으로 평가되지 않기 때문에 다른 값과 결합하거나 변수에 할당할 수 없습니다.

### 예시:
```javascript
// 표현식이 아닌 문 실행 시
var x;
console.log(x); // undefined

// 표현식인 문 실행 시
var y = 10;
console.log(y); // 10
```

---

- **표현식인 문**은 평가된 값을 반환하지만, **표현식이 아닌 문**은 평가된 값을 반환하지 않습니다.
- 크롬 개발자 도구에서는 표현식이 아닌 문을 실행한 경우, 완료 값으로 **`undefined`**를 반환합니다. 이는 변수가 값으로 평가되지 않기 때문입니다.

### 예시:
```javascript
// 표현식이 아닌 문 (if 문 실행)
if (false) {} // 아무 값도 반환되지 않음, 크롬 개발자 도구에서는 undefined 출력

// 표현식인 문
var result = 3 + 5; // 3 + 5는 값으로 평가되므로 표현식, 8 반환
console.log(result); // 8
```

## 6.1 숫자 타입

자바스크립트는 하나의 숫자 타입만 제공하며, 모든 수를 실수(부동소수점)로 처리합니다.  
이는 자바스크립트가 64비트 부동소수점 숫자 형식을 따르기 때문입니다. 즉, 자바스크립트에서는 정수와 실수를 별도로 구분하지 않고 하나의 타입으로 처리합니다.

- **정수(integer)**와 **실수(floating point number)**는 모두 동일한 숫자 타입으로 취급됩니다.
- 자바스크립트는 **2진수, 8진수, 16진수**를 지원하지만, 내부적으로는 모두 10진수로 처리됩니다.

자바스크립트는 숫자 타입이 64비트 부동소수점 형식으로 처리되기 때문에 매우 큰 수나 매우 작은 수를 정확하게 표현할 수 있습니다. 하지만 정수만을 위한 별도의 타입은 제공되지 않으므로, 매우 큰 정수를 처리할 때는 `BigInt`라는 별도의 타입을 사용할 수 있습니다.

### 예시:
```javascript
var integer = 10;     // 정수
var double = 10.12;   // 실수
var negative = -20;   // 음의 정수
console.log(integer, double, negative); // 10 10.12 -20
```

---

## 6.3 템플릿 리터럴

ES6에서 도입된 템플릿 리터럴(Template Literals)은 문자열을 더 쉽게 다룰 수 있도록 개선된 방식입니다.  
이전의 문자열은 작은 따옴표('')나 큰 따옴표("")로 감싸야 했으며, 여러 줄에 걸친 문자열을 사용할 때는 불편함이 있었습니다.

템플릿 리터럴은 다음과 같은 장점이 있습니다:
1. **멀티라인 문자열**: 여러 줄에 걸친 문자열을 손쉽게 작성할 수 있습니다.
2. **표현식 삽입**: `${}` 문법을 사용하여 문자열 안에 변수나 표현식을 쉽게 삽입할 수 있습니다.

### 예시:
```javascript
var first = 'Ung-mo';
var last = 'Lee';
console.log(`My name is ${first} ${last}.`); // My name is Ung-mo Lee.
```

템플릿 리터럴은 백틱(``)으로 문자열을 감싸고, 그 안에 `${}`를 통해 변수나 표현식을 삽입할 수 있습니다. 이를 통해 문자열 안에서 동적으로 데이터를 삽입하고, 계산된 결과를 바로 출력할 수 있습니다.

---

## 6.5 undefined 타입

`undefined`는 자바스크립트에서 변수가 선언되었으나 아직 값이 할당되지 않았을 때 자동으로 할당되는 값입니다.  
즉, 변수를 선언만 하고 값을 넣지 않으면 그 변수는 자동으로 `undefined` 값을 가지게 됩니다.

또한, 함수가 명시적으로 값을 반환하지 않으면 그 함수의 반환값은 `undefined`가 됩니다.

### 예시:
```javascript
var foo;
console.log(foo); // undefined

function noReturn() {}
console.log(noReturn()); // undefined
```

이처럼 `undefined`는 초기화되지 않은 변수나 함수의 반환값으로 자주 등장하며, 이는 자바스크립트가 자동으로 부여하는 기본값입니다.

---

## 6.6 null 타입

`null`은 `undefined`와 마찬가지로 '값이 없다'는 것을 의미하지만, 그 의도가 다릅니다.  
`undefined`는 변수가 선언되었지만 값이 아직 할당되지 않았음을 나타내는 반면, `null`은 명시적으로 변수가 '값이 없음'을 가리키도록 할 때 사용됩니다.

따라서, **`undefined`는 자바스크립트 엔진이 자동으로 할당하는 값**이고, **`null`은 개발자가 의도적으로 할당하는 값**입니다.

### 예시:
```javascript
var foo = null;
console.log(foo); // null
```

`null`을 사용하면 변수가 의도적으로 비어 있음을 표현할 수 있습니다.

---

## 6.7 심벌(Symbol) 타입

`Symbol`은 ES6에서 새롭게 도입된 고유하고 변경 불가능한 데이터 타입입니다.  
심벌은 주로 객체의 프로퍼티 키로 사용되며, 같은 설명이 붙은 심벌이라도 서로 다른 값을 가지므로 절대 중복되지 않습니다.

- **심벌은 유일성**을 보장하는 값입니다.
- 다른 값들과 달리 심벌은 서로 중복되지 않으며, 객체의 고유한 프로퍼티 키로 사용할 수 있습니다.

### 예시:
```javascript
var key1 = Symbol('key');
var key2 = Symbol('key');
console.log(key1 === key2); // false (서로 다른 심벌)
```

심벌은 주로 객체에서 이름 충돌을 방지하기 위해 사용되며, 객체의 프로퍼티 키를 유일하게 만들고자 할 때 사용됩니다.

---

## 6.10 동적 타이핑

자바스크립트는 **동적 타이핑** 언어입니다. 이는 변수를 선언할 때 그 변수의 데이터 타입을 명시적으로 지정하지 않아도 되며, 변수에 할당된 값에 따라 그 타입이 결정된다는 것을 의미합니다.

- 동적 타이핑 덕분에 하나의 변수에 여러 타입의 값을 할당할 수 있습니다.
- 하지만 동적 타이핑은 타입 관련 오류를 발생시킬 수 있기 때문에 주의가 필요합니다.

### 예시:
```javascript
var foo = 42;      // 숫자 타입
foo = 'hello';     // 문자열 타입
console.log(foo);  // hello
```

이처럼 자바스크립트에서 변수의 타입은 런타임 시에 결정되며, 값이 변경되면 변수의 타입도 변경될 수 있습니다.  
동적 타이핑은 유연성을 제공하지만, 예기치 않은 오류를 발생시킬 가능성도 있습니다.



## 9.4 단축 평가

논리 연산자 `&&`, `||`를 사용하면 두 개의 피연산자 중 어느 한쪽만으로 평가를 끝낼 수 있다.  
이러한 평가 방식을 **단축 평가**라고 하며, 왼쪽 피연산자가 평가를 결정할 수 있는 경우 오른쪽 피연산자는 평가되지 않는다.

---

### 논리곱(&&) 연산자
- 첫 번째 피연산자가 `true`일 경우 두 번째 피연산자를 반환한다.
- 예: `Cat && Dog` → `"Dog"`

### 논리합(||) 연산자
- 첫 번째 피연산자가 `true`이면 첫 번째 피연산자를 반환한다.
- 예: `Cat || Dog` → `"Cat"`

---

### 단축 평가를 통한 조건문 대체
- 조건이 `truthy`일 경우 논리곱(&&) 연산자를 사용해 `if` 문을 대체할 수 있다.
- 조건이 `falsy`일 경우 논리합(||) 연산자를 사용해 `if` 문을 대체할 수 있다.
- 예: `done && message = '완료';`

---

### 객체를 참조할 때 null 또는 undefined 확인
- 객체의 프로퍼티를 참조할 때, 객체가 `null` 또는 `undefined`일 경우 오류가 발생한다.
- 단축 평가를 사용해 객체가 `null` 또는 `undefined`인지 확인할 수 있다.
- 예: `value = elem && elem.value;`

---

### 함수 매개변수 기본값 설정
- 함수 호출 시 인수를 전달하지 않으면 매개변수는 `undefined`가 된다.
- 단축 평가를 사용해 매개변수에 기본값을 설정할 수 있다.
- 예: `function getStringLength(str = '') { return str.length; }`

---

## 9.4.2 옵션 체이닝 연산자

- ES11에 도입된 옵션 체이닝 연산자 `?.`는 객체가 `null` 또는 `undefined`인 경우 `undefined`를 반환한다.
- 이를 통해 객체의 프로퍼티를 참조할 때 안전하게 접근할 수 있다.
- 예: `var value = elem?.value;`

---

## 9.4.3 null 병합 연산자

- ES11에 도입된 null 병합 연산자 `??`는 좌항의 피연산자가 `null` 또는 `undefined`일 경우 우항의 값을 반환한다.
- 이를 사용해 기본값을 설정할 수 있다.
- 예: `var foo = null ?? 'default string';`
