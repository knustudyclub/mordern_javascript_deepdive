# Chapter 10: 객체 리터럴

## 10.1 객체의 개념

- 자바스크립트에서 객체는 거의 모든 것을 구성하며, 원시 값을 제외한 모든 데이터가 객체에 속합니다.
- 객체는 하나 이상의 **프로퍼티**로 이루어진 구조로, 각 프로퍼티는 키와 값으로 구성됩니다.
- **프로퍼티**는 객체의 상태를 나타내며, **메서드**는 이 상태를 접근하고 조작하는 함수입니다.

## 10.2 객체 생성 방식: 객체 리터럴

- 객체를 생성하는 방식에는 객체 리터럴, Object 생성자 함수, 생성자 함수, Object.create 메서드, 클래스 등이 있습니다.
- 객체 리터럴은 `{}` 기호를 사용해 객체를 직접 정의하는 방식입니다.

## 10.3 프로퍼티

- **프로퍼티 키**는 문자열 또는 심벌 값으로 설정할 수 있습니다. 카멜 케이스를 사용하는 것이 일반적이며, 필요시 따옴표로 묶어 표현할 수 있습니다.
- **프로퍼티 값**은 자바스크립트에서 허용되는 모든 데이터 유형을 사용할 수 있습니다.
- 동일한 키를 가진 프로퍼티가 중복되면, 마지막으로 정의된 값이 덮어씌웁니다.

## 10.4 메서드

- 객체 내에서 정의된 함수는 **메서드**라고 하며, 객체의 상태 데이터를 참조할 수 있습니다.

## 10.5 프로퍼티 접근

- **점 표기법**: 마침표(`.`)를 사용하여 프로퍼티에 접근할 수 있습니다.
- **대괄호 표기법**: 대괄호(`[]`) 안에 키를 넣어 프로퍼티에 접근합니다.

## 10.6 프로퍼티 값 갱신, 추가, 삭제

- 객체의 기존 프로퍼티 값을 변경하거나 새 프로퍼티를 추가할 수 있습니다.
- `delete` 연산자를 사용해 특정 프로퍼티를 삭제할 수 있습니다.

---

# Chapter 11: 원시 값과 객체의 비교

JavaScript에서 제공하는 데이터 타입은 크게 원시 타입(Primitive Type)과 객체 타입(Object Type)으로 나눌 수 있습니다. 원시 타입은 변경 불가능한 값(immutable value)이며, 객체 타입은 참조 타입입니다.

## 11.1 원시 값

### 원시 값의 특징

- **변경 불가능한 값**: 원시 타입의 값은 한 번 생성되면 변경할 수 없습니다.
- **값의 할당**: 원시 값을 변수에 할당하면 변수에는 실제 값이 저장됩니다. 이러한 방식을 '값에 의한 전달(pass by value)'이라고 합니다. 이는 변수에 저장된 값이 그대로 복사되어 전달되는 것을 의미합니다.
- **변수와 상수**: 원시 값은 변경 불가능한 값을 가지며, 상수는 재할당이 금지된 변수입니다. 하지만 변수는 재할당을 통해 원시 값을 교체할 수 있습니다.

## 11.2 객체

### 객체의 특징

- **동적 속성**: 객체는 속성을 동적으로 추가, 수정, 삭제할 수 있습니다.
- **참조에 의한 전달**: 객체를 변수에 할당하면 변수에는 객체의 참조 값이 저장됩니다. 즉, 객체를 가리키는 메모리 주소를 통해 메모리 공간의 객체에 접근합니다. 이러한 방식을 '참조에 의한 전달(pass by reference)'이라고 합니다.

### 참조 값의 전달

- 객체를 다른 변수에 할당하면 원래 객체의 참조 값이 복사되어 전달됩니다. 따라서 두 변수 중 어느 하나에서 객체를 수정하면 다른 변수에도 영향을 줍니다.

### 객체의 할당과 변경

- 원시 값과 달리 객체는 변경 가능한 값입니다. 따라서 객체를 할당한 변수는 재할당 없이도 객체를 직접 변경할 수 있습니다.
- 여러 변수가 동일한 객체를 참조하고 있는 경우, 한 변수가 객체의 속성을 변경하면 모든 참조가 변경된 상태를 공유하게 됩니다.

## 얕은 복사와 깊은 복사

### 얕은 복사 (Shallow Copy)

- **얕은 복사**: 한 단계까지만 복사하여 원본과 참조 값을 공유합니다. 따라서 얕은 복사로 복사된 객체의 속성을 변경하면 원본 객체도 영향을 받을 수 있습니다.

### 깊은 복사 (Deep Copy)

- **깊은 복사**: 중첩된 객체까지 모두 복사하여 원본과 독립적인 객체를 생성합니다. 깊은 복사는 원본 객체와 복사된 객체가 독립적으로 동작하기 때문에 서로 영향을 주지 않습니다.

## 참조에 의한 전달의 문제점

여러 개의 식별자가 하나의 객체를 공유하는 경우, 객체의 상태가 변경될 때 모든 참조가 영향을 받기 때문에 예기치 않은 오류가 발생할 수 있습니다. 따라서 객체의 상태를 변경하는 작업은 신중하게 이루어져야 합니다.

## 키워드 정리

- **원시 값(Primitive Value)**: 변경 불가능한 데이터
- **객체(Object)**: 참조에 의한 전달이 가능한 데이터
- **얕은 복사(Shallow Copy)**: 한 단계까지만 복사하여 참조 값 공유
- **깊은 복사(Deep Copy)**: 중첩된 객체까지 모두 복사하여 독립적인 객체 생성
- **참조에 의한 전달(Pass by Reference)**: 객체의 참조 값이 복사되어 전달됨

## 추가적인 설명

- **원시 값과 객체의 차이**: 원시 값은 변경 불가능하며 값 자체가 저장되지만, 객체는 참조 타입으로 메모리 주소를 통해 접근합니다.
- **메모리 효율성**: 객체는 메모리 사용을 효율적으로 하기 위해 참조 값이 사용되며, 이를 통해 여러 변수가 하나의 객체를 공유할 수 있습니다.

이와 같은 내용을 바탕으로 원시 값과 객체의 차이를 이해하고, 객체를 다룰 때의 유의점을 알 수 있습니다.

# Chapter 13: 스코프

## 13.2 스코프의 종류

- 자바스크립트는 **전역 스코프**와 **지역 스코프**로 구분됨.
- **전역 스코프**: 코드의 가장 바깥 영역에 선언된 변수. 어디에서든 참조 가능.
- **지역 스코프**: 함수 내부에서 선언된 변수. 해당 함수 내에서만 참조 가능.

## 13.3 스코프 체인

- **스코프 체인(scope chain)**: 변수를 참조할 때, 현재 스코프에서 찾지 못하면 상위 스코프를 따라가며 검색하는 구조.
- 변수를 찾는 과정에서 스코프 체인을 통해 상위 스코프까지 이동하며 변수를 탐색함.

## 13.4 함수 레벨 스코프

- **`var` 키워드**는 함수 레벨 스코프만을 가짐. 코드 블록에서 선언되더라도 함수 전체에서 유효.
- **`let`, `const` 키워드**: 블록 레벨 스코프를 가짐. 코드 블록 내에서만 유효.

## 13.5 렉시컬 스코프

- **렉시컬 스코프(정적 스코프)**: 함수가 정의된 위치에 따라 상위 스코프가 결정됨.
- 자바스크립트는 렉시컬 스코프 방식을 따르며, 함수가 호출된 위치와 관계없이 함수 정의 시의 스코프를 따름.
