# Chap14 전역 변수의 문제점
1. 변수의 생명 주기

	- 지역 변수의 생명 주기: 함수 내부에서 선언된 지역 변수는 함수가 호출될 때 생성되고, 함수 종료 시 소멸합니다.
	-	전역 변수의 생명 주기: 전역 변수는 애플리케이션이 종료될 때까지 메모리에 상주합니다.

2. 전역 변수의 문제점

	-	암묵적 결합: 전역 변수를 여러 함수나 코드 블록에서 공유하면, 코드 간의 의존성이 높아져 유지보수가 어려워집니다.
	-	긴 생명 주기: 전역 변수는 프로그램 종료 시까지 메모리에 존재하므로, 메모리 자원을 오랜 기간 점유하게 됩니다.
	-	스코프 체인 상에서의 시간 소모: 변수를 검색할 때 스코프 체인을 따라가므로, 전역 변수는 검색에 시간이 더 소요될 수 있습니다.
	-	네임스페이스 오염: 전역 변수가 많아지면 이름 충돌의 위험이 높아지고, 이는 예기치 않은 동작을 유발할 수 있습니다.

3. 전역 변수 사용 억제 방법

	-	즉시 실행 함수: 함수를 정의함과 동시에 실행하여, 함수 내부에 변수를 선언함으로써 전역 변수의 생성을 방지합니다.
	-	네임스페이스 객체: 전역 변수를 객체의 프로퍼티로 정의하여, 전역 변수의 수를 줄이고 네임스페이스를 분리합니다.
	-	모듈 패턴: 클로저를 활용하여 전역 변수의 생성을 억제하고, 모듈화된 코드를 작성합니다.
	-	ES6 모듈: ES6의 모듈 시스템을 사용하여 파일 단위로 모듈을 분리하고, 전역 변수의 생성을 방지합니다.

# Chap15 let, const 키워드와 블록 레벨 스코프
1. var 키워드의 문제점
- 변수 중복 선언 허용: var로 선언된 변수는 동일한 스코프 내에서 중복 선언이 가능하여, 의도치 않은 값의 변경이 발생할 수 있습니다.
- 함수 레벨 스코프: var는 함수 레벨 스코프를 가지므로, 블록 레벨 스코프를 지원하지 않아 코드의 가독성과 유지보수성이 떨어집니다.
- 변수 호이스팅: var로 선언된 변수는 호이스팅되어 선언 전에 접근할 수 있지만, 이는 예기치 않은 동작을 유발할 수 있습니다.

2. let 키워드

- 변수 중복 선언 금지: let으로 선언된 변수는 동일한 스코프 내에서 중복 선언이 불가능하여, 변수의 재선언으로 인한 오류를 방지합니다.
- 블록 레벨 스코프: let은 모든 코드 블록을 스코프로 인정하여, 블록 단위로 변수를 관리할 수 있습니다.
- 변수 호이스팅: let으로 선언된 변수도 호이스팅되지만, 선언 전에 접근하면 참조 에러가 발생하여 안전성을 높입니다.

3. const 키워드

- 선언과 초기화: const로 선언된 변수는 선언과 동시에 초기화해야 하며, 이후 재할당이 불가능합니다.
- 상수: 변경되지 않는 값을 상수로 선언할 때 const를 사용하며, 상수의 이름은 대문자로 작성하는 것이 관례입니다.
- 객체와 배열: const로 선언된 객체나 배열은 재할당은 불가능하지만, 내부 프로퍼티나 요소의 변경은 가능합니다.

4. var, let, const의 비교 및 권장 사항

- var 사용 지양: var의 문제점으로 인해 사용을 지양하고, 대신 let과 const를 사용합니다.
- let과 const의 사용: 재할당이 필요한 경우에만 let을 사용하고, 그렇지 않은 경우에는 기본적으로 const를 사용하는 것이 좋습니다.
