16

### **프로퍼티 어트리뷰트의 종류**
#### **데이터 프로퍼티**: 키와 값으로 구성된 일반적인 프로퍼티.
  - [[Value]]: 프로퍼티 값.
  - [[Writable]]: 값을 변경할 수 있는지 여부 (true/false).
  - [[Enumerable]]: 열거 가능 여부 (for...in/Object.keys 포함).
  - [[Configurable]]: 삭제 및 어트리뷰트 수정 가능 여부.
#### **접근자 프로퍼티**: 값이 아닌 함수로 정의되는 프로퍼티.
  - [[Get]]: 프로퍼티를 읽을 때 호출되는 함수.
  - [[Set]]: 프로퍼티에 값을 할당할 때 호출되는 함수.
#### **프로퍼티 디스크립터**
- 프로퍼티의 어트리뷰트를 확인하거나 수정할 때 사용.
- Object.getOwnPropertyDescriptor(obj, prop)
    - 객체의 특정 프로퍼티의 어트리뷰트를 반환.
- Object.defineProperty(obj, prop, descriptor)
    - 프로퍼티를 정의하거나 어트리뷰트를 변경.
#### **접근자 프로퍼티**
- get과 set을 사용하여 프로퍼티 동작을 커스터마이징.

- 프로퍼티 어트리뷰트를 이용하면 데이터의 불변성, 은닉성, 또는 커스터마이징된 동작을 구현 가능.
- 접근자 프로퍼티를 사용하면 값을 직접 저장하지 않고 계산된 값을 반환하거나, 특정 조건으로 값을 설정 가능.

17

#### **객체 생성 방식**
- 리터럴 방식
- Object.create를 사용한 방식
- 생성자 함수를 사용한 방식
#### **생성자 함수**
- 일반 함수와의 차이점은 new 연산자 사용.
- new로 호출하면 내부적으로 다음과 같은 동작이 수행됨:
    - 빈 객체 생성 및 this 바인딩.
    - 생성자 함수 코드 실행 (this에 프로퍼티 추가).
    - 생성된 객체 반환.
#### **프로토타입과 생성자 함수**
- 생성된 객체는 생성자 함수의 prototype 객체를 상속.
- 프로토타입 객체에 메서드를 정의하면 모든 인스턴스에서 공유.
#### **객체 리터럴 vs 생성자 함수**
- 리터럴 방식은 한두 개의 객체를 만들 때 유용.
- 생성자 함수는 다수의 객체를 일관된 방식으로 생성 가능.

- 생성자 함수의 prototype을 활용하면 메모리 효율적으로 메서드를 공유.
- 생성자 함수는 일반 함수처럼 호출할 수 있으나, new 없이 호출하면 this가 전역 객체를 참조하므로 주의 필요.
- ES6 클래스 문법 도입으로 생성자 함수의 필요성이 줄어들었지만, 기존 코드나 프로토타입 기반 상속 이해에 여전히 중요.
